<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      .cerceve {
        border: solid 3px black;
      }
    </style>
    <title>SQL</title>
  </head>
  <body>
    <main>
      <h1>SQL (Structured Query Language)</h1>

      <h2>Database(Veritabani)</h2>
      Bilgilerin depolandigi alandir. <br /><br />
      DBMS ile kontrol edilir. <br /><br />
      <hr />
      <h2>DBMS(Data Base Management System</h2>
      Veri tabaninji yönetmek, kullanmak, gelistirmek ve bakim yapmak icin
      kullanilan yazilimlardir. <br /><br />
      CRUD(Create, Read, Update, Delete) islemlerini düzenler. <br /><br />
      Data güvenligini saglar. <br /><br />
      form, sorgu, ve rapor olusturur ve isletir. <br /><br />
      Uygulanmayi kontrol eder. <br /><br />
      Diger uygulamalarla iletisimi saglar.
      <hr />
      <h2>Tables(Tablolar)</h2>
      <strong>Headers</strong> : Tablo basliklarina denir. (ID, name, email vs)
      <br /><br />
      <strong>Row(Record)</strong> : Satirlara denir. <br /><br />
      <strong>Column(Field)</strong> : Sütunlara denir. <br /><br />
      Birbiriyle herhangi bir bilgi ile baglanan tablolara
      <strong>Relational Databases(iliskili tablolar)</strong> denir. (Ögrenci
      No-Ögrenci No ) Ayni zamanda <strong>SQL Databases</strong> olarak da
      adlandirilir.<br /><br />
      Tablolar ve iliskilerinin bütününe
      <strong>Schema</strong> denir.(selenium'daki Faramework gibi)
      <hr />
      <h2>Piyasadaki bilinen Relational Databases (SQL Database)</h2>
      <ul>
        <li>SQL Server (Microsoft)</li>
        <li>MySQL Server (Oracle)</li>
        <li>PostgreSQL Server</li>
        <li>PL/SQL (Oracle)*</li>
      </ul>
      <hr />
      <h2>SQL Komutlari</h2>
      SQL Komutlari dört ana gruba ayrilir:
      <ol>
        <li>
          DQL(Data Query Language)- Veri Sorgulama Dili
          <ul>
            <li><strong>SELECT</strong> : Veri tabanindaki verileri alir.</li>
          </ul>
        </li>
        <li>
          DML(Data Manipulation Language)- Veri Kullanma Dili
          <ul>
            <li><strong>INSERT</strong> :Veri tabanina yeni veri ekler.</li>
            <li>
              <strong>UPDATE</strong> :Veri tabanindaki verileri günceller.
            </li>
            <li>
              <strong>DELETE</strong> :Veri tabanindaki verileri siler.
              <br />//DML(ic islemler) insert update delete
            </li>
          </ul>
        </li>
        <li>
          DDL(Data Definition Language)- Veri Tanimlama Dili
          <ul>
            <li>
              <strong>CREATE</strong> :Bir veritabani veya veritabani icinde bir
              tablo olusturur.
            </li>
            <li>
              <strong>ALTER</strong> :Bir veritabani veya veritabnai icindeki
              tabloyu günceller.
            </li>
            <li>
              <strong>DROP</strong> :Bir veritabani veya veritabani icindeki
              tabloyu siler. <br />//DDL islemleri (dis islemler)create alter
              drop
            </li>
          </ul>
        </li>
        <li>
          DCL(Data Control Language)- Veri Kontrol Dili
          <ul>
            <li>
              <strong>GRANT</strong> :Bir kullaniciya yetki vermek icin
              kullanilir.
            </li>
            <li>
              <strong>REVOKE</strong> :Bir kullaniciya verilen yetkiyi geri
              almak icin kullanilir.
            </li>
          </ul>
        </li>
      </ol>
      <hr />
      <h3>Primary Key</h3>
      //not Null, Unique, parent. <br /><br />
      Bir veri tablosunda <strong>tek olmasi gereken</strong> bir veri icin
      kisitlama anahtaridir.(Ögrenci No) <br /><br />
      Bos gecilemez. <br /><br />
      NULL degeri alamaz. <br /><br />
      Bir tabloda en fazla <strong>bir adet primary key</strong> olabilir.
      <br /><br />
      Her tabloda primary key olmasi <strong>zorunlu degil</strong>dir.
      <br /><br />
      Primary key her tür datayi icerebilir.(String, sayi vs) <br /><br />
      Her benzersiz olan data primary key degildir. <br /><br />
      Primary key eger gercek dünyadaki verileri iceriyorsa (tc no) buna
      <strong>Natural Key</strong> denir. <br /><br />
      Herhangi bir kayit eklenmeden üretilen sira numarasi gibi sayisal
      degerlere <strong>Surrogate Key</strong> denir.
      <hr />
      <h3>Foreign Key</h3>
      //null olabilir, Unique sart degil, child. <br /><br />
      Iki tablo arasinda <strong>bag olusturmak icin</strong> kullanilan
      anahtardir. <br /><br />
      Foreign Key baska bir tablodaki
      <strong>Primary Key</strong> ile iliskilendirilmis olmalidir. <br /><br />
      Bir tabloda birden fazla foreign key olabilir. <br /><br />
      Foreign Key <strong>NULL</strong> degeri kabul eder. <br /><br />
      Unique olma zorunlulugu yoktur. <br /><br />
      Ayni tablo icerisinde de bir relation (bag) olusturulabilir.
      <hr />
      <h3>Composite Key</h3>
      Birden fazla field(sütun)'in kombinasyonu ile olusturulur. <br /><br />
      Eger tek basina bir sütun primary key olma özelligi tasimiyorsa birden
      fazla kolon birlestirilerek Primary olusturulur.
      <hr />
      <h3>Unique Key</h3>
      Bir tabloda birden fazla olabilir. <br /><br />
      <strong>NULL</strong> degeri kabul eder. <br /><br />
      Dublication'a(cift kullanim) izin vermez.
      <hr />
      <h2>SQL Data Types</h2>
      SQL'de dört cesit data tipi mevcuttur.
      <ol>
        <li>
          String Data Types
          <ul>
            <li>
              <strong>char(size)</strong> :
              <ul>
                <li>Maximum boyutu 2000 byte olabilir.</li>
                <li>1 karakter 1 byte kullanir.</li>
                <li>"size" database'e eklenecek karakter sayisidir.</li>
                <li>Uzunlugu sabit datalari depolar.</li>
                <li>
                  SSN, zip code gibi uzunlugu sabit datalari depolamak icin
                  idealdir. <br />
                  //Girilen datanin net uzunlugu
                  <strong>biliniyorsa</strong> tercih edilmelidir.
                </li>
              </ul>
            </li>
            <li>
              <strong>nchar(size)</strong> :
              <ul>
                <li>Maximum boyutu 2000 byte olabilir.</li>
                <li>1 karakter 2 byte kullanir.</li>
                <li>"size" depolanacak karakter sayisidir.</li>
                <li>Unicode datalari depolamak icin kullanilir.</li>
                <li>Farkli dillerdeki karakterler icin kullanilir.</li>
                <li>Uzunlugu belli stringler icin kullanilir.</li>
              </ul>
            </li>
            <li>
              <strong>varchar2(size)</strong> :
              <ul>
                <li>Maximum boyutu 4000 byte olabilir.</li>
                <li>1 karakter 1 byte kullanir.</li>
                <li>"size" database'e eklenecek maximum karakter sayisidir.</li>
                <li>
                  Degisken uzunluktaki String'ler icin kullanilir.
                  <br />
                  //Girilen datanin net uzunlugu
                  <strong>bilinmiyorsa</strong> tercih edilmelidir.
                </li>
              </ul>
            </li>
            <li>
              <strong>nvarcahr2(size)</strong> :
              <ul>
                <li>Maximum boyutu 8000 byte olabilir.</li>
                <li>1 karakter 2 byte kullanir.</li>
                <li>"size" dopolanacak karakter sayisidir.</li>
                <li>
                  Degisken uzunluktaki String'lerin Unicode degerleri icin
                  kullanilir.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          Numeric Data Types
          <ul>
            <li>
              <strong>number(p)</strong> :
              <ul>
                <li>(p) sayidaki rakam sayisidir. (precision)</li>
                <li>(p) 1 ile 38 arasinda bir deger yazilabilir.</li>
                <li>
                  (p)'den az sayida rakam girebilirsiniz ama fazlasini
                  giremezsiniz.
                </li>
              </ul>
            </li>
            <li>
              <strong>number(p,s)</strong> :
              <ul>
                <li>
                  (s) virgülden sonra kac rakam oldugunu belirler. (scale)
                  <br />
                  Örnegin: 1234,56 = number(6,2)
                </li>
                <li>(s) -84 ile 127 arainda deger alabilir.</li>
                <li>number(4,2)=123,45 hata verir.</li>
                <li>
                  number(7) 12345,67 olarak kabul etse de 12345 olarak depolar.
                </li>
                <li>number(7) ile number(7,0) aynisir.</li>
                <li>
                  number(7,-2) 1234567,89 virgulden 2 basamak sola gelerek
                  yuvarlar: 1234600
                </li>
                <li>Baska proramlarda degisik kullanimlari vardir.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          Date Data Types
          <ul>
            <li>
              <strong>DATE</strong> :
              <ul>
                <li>
                  Tarih ve zamani depolamak icin kullanilir. Saniyennin virgüllü
                  kismini da alir.
                </li>
                <li>Yil, ay, gün, saat, dakika, saniye icerir</li>
                <li>formati dd-MMM-yy(13-Apr-21) seklindedir.</li>
                <li>
                  Tarih formati ALTER SESSION SET NLS_DATE_FORMAT="YYYY_MM_DD"
                  yazilarak 2021-04-18'e degistirilebilir.
                </li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          Blob Data Types
          <ul>
            <li>
              <strong>BLOB</strong> :
              <ul>
                <li>Binary Large OBject demektir.</li>
                <li>
                  Resim video ses gibi datalari binary formatina cevirerek
                  depolar.
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
      <hr />
      <strong>Oracle SQL Developer</strong> programinda calismaya baslamak icin:
      <br />
      File'in altindaki dosya isaretine bas &gt; Database Tier &gt; Database
      Files &gt; SQL file dosyasini sec &gt; Tamam &gt; File Name =day1
      &gt;Directory = Masaüstünde olusturulan SQL Klosörünü sec &gt; Select &gt;
      Tamam <br />Worksheet acilmistir.
      <hr />
      <h4>Bazi kisa aciklamalar:</h4>
      <ul>
        <li>
          Yorum satir yapmak icin -- isareti ile baslanmalidir. <br />Eger
          paragraf yorum yapmak istersek /* */ arasina yazilir.
        </li>
        <li>
          Yazilan kelimeyi büyük veya kücük harfe cevirmek icin yukaridaki Aa
          simgesine basmak yeterli olur.
        </li>
        <li>
          Eger satir numaralarini görmek istersek satir basindaki bos sütuna
          gelip sag tiklayip Toggle Line Numbers secenegine tiklayalim.
        </li>
        <li>
          Eger dosya adi egik cikiyorsa mutlaka ayrilmadan önce kaydetmeliyiz.
        </li>
        <li></li>
      </ul>
      <hr />
      <h3>Tablo Olusturma</h3>
      <div class="cerceve">
        <code
          >CREATE TABLE student <br />
          ( <br />
          id CHAR(4), <br />
          name VARCHAR(20), <br />
          age NUMBER <br />
          );</code
        >
      </div>
      Degerler arasina virgül konur. <br /><br />
      Yazilan kodun sonuna gelip mouse'umuzu tiklayip run isaretini kullanarak
      calistirabilecegimiz gibi sadece sectigimiz kismi da calistirabiliriz.
      Burada run tusuna basarsak student isminde bir tablo create edilmis
      olacaktir.(eger ayni isimde tablo yoksa)
      <hr />
      <h3>Tabloya Veri Girisi</h3>
      Olusturulan tabloda id, name, age header'lari mevcut.
      <div class="cerceve">
        <code>INSERT INTO student VALUES('1001','MEHMET CAN',25);</code>
      </div>
      Olusturulan tablodaki siraya göre veriler girilmelidir. <br /><br />
      NUMMER icin tek tirnakli yazmaya gerek yoktur. <br /><br />
      CHAR ve VARCHAR degerleri icin tirnak kullanmak sarttir.
      <h4>Eger parcali veri girisi yapmak istersek:</h4>
      <div class="cerceve">
        <code>INSERT INTO student(id,name) VALUES('1002','FATMA CANLI');</code>
      </div>
      Girilmeyen age kismi <strong>(null)</strong> olacaktir.
      <hr />
      <h3>Tablodan Veri Sorgulama</h3>
      <div class="cerceve"><code>SELECT * FROM student;</code></div>
      Yildiz tablodaki her seyi getir göster manasina gelir.
      <hr />
      <h3>Tablo Silme</h3>
      Tablo acikken silinmez! <br />
      Child silinmeden Parent silinmez. <br />Bir tabloyu
      <strong>DROP</strong> komutuyla silersek tablo geri dönüsüm kutusuna
      gönderilir.
      <div class="cerceve"><code>DROP TABLE student;</code></div>
      Eger Tabloyu manuel silmek istersek; <br />
      sol taraftaki Connections kismi &gt; silmek istedigimiz tabloya gelip sag
      tikla &gt; Table &gt; Drop &gt; Uygula <br /><br />
      Eger cöp kutusuna degil de tamamen silinsin istersek uygula demeden
      <strong>Purge</strong> secenegini isaretlemeliyiz. <br />
      Kod ile yazmak istersek;
      <div class="cerceve"><code>DROP TABLE student PURGE;</code></div>
      Eger zaten cöp kutusuna göndermissek ve geri getirilemeyecek sekilde kod
      ile silmek istiyorsak;
      <div class="cerceve"><code>PURGE TABLE student;</code></div>
      <br />
      Eger cöp kutusuna gönderdigimiz bir dosyayi yeniden yüklemek istersek;
      <br />
      istenilen doyaya sag tikla &gt; Flashback to Before Drop secenegine bas.
      <br />
      Eger bunu kod ile yapmak istersek;
      <div class="cerceve">
        <code>FLASHBACK TABLE student TO BEFORE DROP;</code>
      </div>
      <br />
      Bir tabloyu <strong>TRUNCATE</strong> komutunu kullanarak silersek datalar
      artik geri getirilemez.
      <div class="cerceve"><code>TRUNCATE TABLE student;</code></div>
      <br />
      Eger tabloyu degil de tablonun icindeki datalari silmek istersek;
      <div class="cerceve"><code>DELETE FROM student;</code></div>
      <br />
      Eger tablonun icindeki bir sütunu silmek istersek; (?)
      <div class="cerceve">
        <code
          >DELETE FROM student <br />
          WHERE sehir;
        </code>
      </div>
      Eger bir satiri silmek istersek;
      <div class="cerceve">
        <code>
          DELETE FROM student <br />
          WHERE ogrenci_no = 124;
        </code>
      </div>
      Eger birden fazla satiri silmek istersek;(ikisini de siler)
      <div class="cerceve">
        <code>
          DELETE FROM student <br />
          WHERE ogrenci_no = 124 OR ogrenci_no = 132;
        </code>
      </div>
      veya (OR yerine IN)
      <div class="cerceve">
        <code>
          DELETE FROM student <br />
          WHERE ogrenci_no IN (124,126,128);
        </code>
      </div>
      veya
      <div class="cerceve">
        <code>
          DELETE FROM student <br />
          WHERE ogrenci_no &gt; 124;
        </code>
      </div>
      Eger bir satirda iki sart ile silmek istersek; (ikisini de ayni satirda
      bulmasi lazim ki silebilsin)
      <div class="cerceve">
        <code>
          DELETE FROM student <br />
          WHERE ogrenci_isim = 'Ali Can' AND ogrenci_no = 132;
        </code>
      </div>
      Eger silinen verileri geri getirmek istersek(?)
      <div class="cerceve">
        <code>
          ROLLBACK TO ABC; <br />
          SELECT * FROM student;
        </code>
      </div>
      <br />
      <strong>ON DELETE CASCADE</strong> : parent de olsa bir tabloyu silebilmek
      baglanti yaparken <strong>REFERENCES</strong> ten sonra yazilmali
      <div class="cerceve">
        <code>
          CONSTRAINT aciklama FOREIGN KEY kendi_tablo_degeri <br />
          REFERENCES diger_tablo(diger_tablo_degeri) ON DELETE CASCADE
        </code>
      </div>
      <hr />
      <h3>Iki Tabloyu Birbirine Baglama</h3>
      <div class="cerceve">
        <code
          >CREATE TABLE adresler( <br />
          adres_id CHAR(5), <br />
          CONSTRAINT id_foreign FOREIGN KEY(adres_id) REFERENCES calisanlar(id)
          <br />
          );
        </code>
      </div>
      Calisanlar tablosu önceden olusturulmus olmali ve calisanlar tablosundaki
      id primary key olmali.
      <hr />
      <h3>Tablodaki Bilgileri Güncelleme</h3>
      Ögrenci numarasi 1002 olan ögrencinin sinav notunu 85 olarak
      güncelleyelim;
      <div class="cerceve">
        <code>
          UPDATE ogrenciler <br />
          <strong>SET</strong> sinav_notu= 85 <br />
          WHERE ogrenci_no=1002;
        </code>
      </div>
      sütunun tamamini ayni degerle güncelleyeceksek yer belirtmeye(WHERE) gerek
      yok. <br />
      Eger 50'nin altinda alan ögrencilerin sinav notunun +5 artmasini
      isteseydik;
      <div class="cerceve">
        <code>
          UPDATE ogrenciler <br />
          SET sinav_notu= sinav_notu+5 <br />
          WHERE sinav_notu&lt;50;
        </code>
      </div>
      Eger birbirine bagli iki tabloda degisiklik yapmak isteseydik; <br />
      Sinav notu kismina ortalamasi 50 alti olanlara sinav tablosundan bütünleme
      sinavi tarihi yazilsin)
      <div class="cerceve">
        <code>
          UPDATE ogrenciler <br />
          SET sinav_notu=(SELECT butunleme_tarihi FROM sinavlar) <br />
          WHERE ortalama&lt;50);
        </code>
      </div>
      <hr />
      <h3>CONSTRAINTS - KISITLAMALAR</h3>
      Kisitlamalari tablo olustururken yazmamiz gerekir.
      <ul>
        <li>
          <strong>NOT NULL</strong> : Bir Sütunun NULL içermemesini garanti
          eder.
          <ul>
            <li><code>id CHAR(4) NOT NULL</code></li>
          </ul>
        </li>
        <li>
          <strong>UNIQUE</strong> : Bir sütundaki tüm değerlerin BENZERSİZ
          olmasını garanti eder. Birden fazla null kabul edebilir.
          <ul>
            <li><code>id CHAR(4) UNIQUE</code></li>
          </ul>
        </li>
        <li>
          <strong>PRIMARY KEY</strong> : Bir sütunun NULL içermemesini ve
          sütundaki verilerin BENZERSİZ olmasını garanti eder.(NOT NULL ve
          UNIQUE birleşimi gibi)
          <ul>
            <li><code> id CHAR(5) PRIMARY KEY </code></li>
          </ul>
          Istersek kisitlamaya kendimiz isim atayabiliriz ama isi uzatiriz;
          <ul>
            <li>
              <code
                >id CHAR(5), <br />
                CONSTRAINT id_primary PRIMARY KEY(id)
              </code>
            </li>
          </ul>
        </li>
        <li>
          <strong>FOREIGN KEY</strong> : Başka bir tablodaki Primary Key'i
          referans göstermek için kullanılır. Böylelikle, tablolar arasında
          ilişki kurulmuş olur.
          <ul>
            <li>
              <code
                >CREATE TABLE adresler( <br />
                adres_id CHAR(5), <br />
                CONSTRAINT id_foreign FOREIGN KEY(adres_id) REFERENCES
                calisanlar(id) <br />
                );
              </code>
              <br />
              //adresler ile calisanlar tablosu birbirine baglanmis oldu.
              (calisanlar(id) primary key olmali) <br />
              //Calisanlar tablosu parent oldu. <br />
              //Parent'ta olmayan id'li veri girisine(INSERT) izin verilmez.
              //iki farkli veri foreign key yapilarak baska bir tablodaki ayni
              data tiplerine(primary key'e sahip) baglanabilir.
            </li>
          </ul>
        </li>
        <li>
          <strong>CHECK</strong> : Bir sutundaki tüm verilerin belirlenen özel
          bir şartı sağlamasını garanti eder. Null deger alabilir. <br />
          <code> nufus NUMBER(8,0) CHECK (nufus&gt;1000) </code>
        </li>
      </ul>
      <hr />
      <h3>Istenilen Bir Sarti Listeleme</h3>
      Ögrenciler tablosundan sinav notu 80'den büyük olan ögrencileri
      listeleyelim.
      <div class="cerceve">
        <code
          >SELECT *FROM ogrenciler <br />
          WHERE sinav_notu>80;
        </code>
      </div>
      Eger adresi Ankara olan ögrencilerin numara ve isimlerini isteseydik;
      <div class="cerceve">
        <code
          >SELECT ogrenci_no, isim FROM ögrenciler <br />
          WHERE adres= 'Ankara';
        </code>
      </div>
      Eger notu 60 ile 80 arasinda olan ögrencileri listeleseydik;
      <div class="cerceve">
        <code
          >SELECT * FROM ogrenciler <br />
          WHERE sinav_notu <strong>BETWEEN</strong> '60' AND '80';
        </code>
      </div>
      veya
      <div class="cerceve">
        <code
          >SELECT * FROM ogrenciler <br />
          WHERE sinav_notu &gt;= '60' AND sinav_notu &lt;='80';
        </code>
      </div>
      Sinirda olanlari dahil ediyor. <br />
      Illa ki sayisal bir deger olmasina gerek yok, harf olarak da getirebilir.
      <br />
      Eger bu aralikta nota sahip olmayanlarin soyadlarini listelemek
      isteseydik;
      <div class="cerceve">
        <code
          >SELECT soyad FROM ogrenciler <br />
          WHERE sinav_notu <strong>NOT BETWEEN</strong> '60'
          <strong>AND</strong> '80';
        </code>
      </div>
      Sinirda olanlari dahil etmiyor. <br />
      Eger sadece istenilen notlara sahip ögrencileri isteseydik;
      <div class="cerceve">
        <code
          >SELECT * FROM ogrenciler <br />
          WHERE sinav_notu <strong>IN</strong> (60,70,80);
        </code>
      </div>
      Gelen notlar icinde 75 notu olan bir ögrenci olmayacak.
      <hr />
      <h3>Operatör Ifadeleri</h3>
      <strong>WHERE</strong> komutu ile kullanilan mantiksal operatörlerdir.
      <ul>
        <li><strong>=</strong> : Esittir</li>
        <li>
          <strong>&lt;&gt;</strong> : Esit degil (!= seklinde de
          kullanilabilir).
        </li>
        <li><strong>&gt;</strong> : Büyüktür</li>
        <li><strong>&lt;</strong> : Kücüktür</li>
        <li><strong>&gt;=</strong> : Büyüktür veya esittir</li>
        <li><strong>&lt;=</strong> : Kücüktür veya esittir</li>
        <li>
          <strong>AND</strong> : Ve yerine kullanilir <br /><code
            >WHERE urun_id&gt;=20 AND urun_id&lt;=40;</code
          >
        </li>
        <li>
          <strong>OR</strong> : IN yerine kullanilir ama her araya OR
          yazilmalidir. <br />
          <code
            >WHERE urun_isim ='Orange' OR urun_isim ='Apple' OR urun_isim
            ='Apricot';</code
          >
        </li>
        <li>
          <strong>BETWEEN</strong> : Iki veri arasindaki ifadelerdir(dahil)
          <br /><code>WHERE urun_id BETWEEN 20 AND 40 ;</code>
        </li>
        <li>
          <strong>IN</strong> : nokta atis verilen ifadelerdir <br />
          <code>WHERE urun_isim IN ('Orange', 'Apple', 'Apricot');</code>
        </li>
      </ul>
      <hr />
      <h3>Subquery</h3>
      Eger bir sorgunun icinde baska bir sorgu ile getirilen data varsa bu ic
      ice sorguya <strong>subquery</strong> denir.
      <div class="cerceve">
        <code>
          UPDATE ogrenciler <br />
          SET sinav_notu=(SELECT butunleme_tarihi FROM sinavlar) <br />
          WHERE ortalama&lt;50);
        </code>
      </div>
      <hr />
      <h3>EXISTS</h3>
      *IN yerine EXIST de yazilabilir:
      <div class="cerceve">
        <code>
          SELECT urun_id, musteri_isim FROM mart_satislar <br />
          WHERE urun_id IN (SELECT urun_id FROM nisan_satislar <br />
          WHERE mart_satislar.urun_id=nisan_satislar.urun_id);
        </code>
      </div>
      yerine;
      <div class="cerceve">
        <code>
          SELECT urun_id, musteri_isim FROM mart_satislar <br />
          WHERE <strong>EXISTS</strong>(SELECT urun_id FROM nisan_satislar
          <br />
          WHERE mart_satislar.urun_id=nisan_satislar.urun_id);
        </code>
      </div>
      EXISTS; bir baktigi degere tekrar bakmadigi icin IN e göre daha
      <strong>hizli</strong>dir.
      <hr />
      <h2>AGGREGATE FONKSIYONLAR</h2>
      <ul>
        <li><strong>SUM</strong> : Toplam</li>
        <li><strong>COUNT</strong> : Adet(Sayac)</li>
        <li><strong>ROUND</strong> : Yuvarla</li>
        <li><strong>MIN</strong> : Minimum deger</li>
        <li><strong>MAX</strong> : Maximum deger</li>
        <li><strong>AVG</strong> : Ortalama</li>
      </ul>
      <hr />
      <h3>Örnekler</h3>
      Sirketler ve personel tablosu var. Her sirketin, adini personel sayisini
      ve ödedigi maas <strong>toplam</strong>ini bulalim;
      <div class="cerceve">
        <code
          >SELECT sirket_adi,personel_sayisi,(SELECT <strong>SUM</strong>(maas)
          FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket)
          <strong>AS</strong> toplam_maas <br />
          FROM sirketler;
        </code>
      </div>
      Sirketler tablosundaki "sirket_adi" ile personel tablosundaki "sirket"
      datalarinin uyustugu yerdekiler manasina gelir. <br />
      <strong>AS</strong> ; bir sütuna isim vermek icin kullanilir. yazilmazsa
      hata vermez, calisir. <br />
      Parantez icinde subquery kullanilmistir. <br /><br />
      Sirketlerin adini, personel sayisini ve verdigi maas
      <strong>ortalama</strong>sini bulalim;
      <div class="cerceve">
        <code
          >SELECT sirket_adi,personel_sayisi,(SELECT <strong>AVG</strong>(maas)
          FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket) AS ortalama_maas <br />
          FROM sirketler;
        </code>
      </div>
      Eger maas ortalamalari virgüllü sayilar cikarsa parantez icine alip
      <strong>yuvarla</strong>yabiliriz.
      <div class="cerceve">
        <code
          >(SELECT <strong>ROUND</strong> (AVG(maas)) FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket)
        </code>
      </div>
      <br /><br />
      Sirketlerin adini, personel sayisini ve sirket personelinin
      <strong>minimum</strong> ve <strong>maximum</strong> maasini bulalim;
      <div class="cerceve">
        <code
          >SELECT sirket_adi,personel_sayisi,(SELECT <strong>MAX</strong>(maas)
          FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket) AS max_maas, <br />
          (SELECT <strong>MIN</strong>(maas) FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket) AS min_maas <br />
          FROM sirketler;
        </code>
      </div>
      <br /><br />
      Sirketlerin ID kodunu, ismini ve toplam kac sehirde bulundugunu listeleyen
      bir sorgu yazalim;
      <div class="cerceve">
        <code
          >SELECT sirket_id,sirket_adi,(SELECT <strong>COUNT</strong>(sehir)
          FROM personel
          <br />
          WHERE sirketler.sirket_adi=personel.sirket) AS sehir_sayisi <br />
          FROM sirketler;
        </code>
      </div>
      <hr />
      <h3>IS NULL, IS NOT NULL</h3>
      Bir ifadenin <strong>NULL</strong> olup olmadigini kontrol eder.
      <br /><br />
      Ismi NULL girilenleri sorgulayiniz.
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE isim IS NULL;
        </code>
      </div>
      Eger ismi NULL olanlarin isimlerine "NO NAME" yazisi atasaydik;
      <div class="cerceve">
        <code>
          UPDATE personel <br />
          SET isim= 'NO NAME' <br />
          WHERE isim IS NULL;
        </code>
      </div>
      <hr />
      <h3>COALESCE</h3>
      Null olmayanlari bize gösterir. <br />
      <div class="cerceve">
        <code> SELECT COALESCE (isim,ssn,adres) FROM insanlar; </code>
      </div>

      Burada önce isimlere bakti ve ismi olmayana denk gelince ssn numarasini
      getirdi, ikisi de yoksa adresini getirdi.
      <div class="cerceve">
        <code>
          UPDATE insanlar <br />
          SET isim= COALESCE (isim,'Henuz isim girilmedi'), <br />
          adres=COALESCE (adres,'Henuz adres girilmedi'), <br />
          ssn=COALESCE (ssn,'ssn yok');
        </code>
      </div>
      null lari istenilen degerlerle degistirdi.
      <hr />
      <h2>SIRALAMA - ORDER BY</h2>
      ORDER BY cümleciği bir <strong>SORGU</strong> deyimi içerisinde belli bir
      <strong>SUTUN</strong>'a göre <strong>SIRALAMA</strong> yapmak için
      kullanılır.
      <ul>
        <li>ORDER BY sutun_adi ASC -- ARTAN</li>
        <li>ORDER BY sutun_adi DESC -- AZALAN</li>
      </ul>
      Kisiler tablosunu adrese göre siralayalim;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY adres;
        </code>
      </div>
      Kisiler tablosunu maasa göre tersten(azanalan) siralayalim;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY maas DESC;
        </code>
      </div>
      Soyadi Bulut olanlari isim sirasina göre sorgulayalim;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          WHERE soyisim='Bulut' ORDER BY 2;
        </code>
      </div>
      Isim yerine sutun sirasini da kullanabiliriz.
      <hr />
      <h3>Istenilen Satirlari Getirme & Atlama (FETCH NEXT & OFFSET)</h3>
      12C VE ÜSTÜ oracle larda çalışır, daha altsanız çalışmaz. <br /><br />
      FETCH cümleciği ile listelenecek kayıtları sınırlandırabiliriz. İstersek
      satır sayısına göre istersek de toplam satır sayısının belli bir yüzdesine
      göre sınırlandırma koymak mümkündür. (şu kadar satırı getir) <br /><br />
      Maasi en yüksek ilk üc kisiyi sorgulayalim;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY maas DESC <br />
          FETCH NEXT 3 ROWS ONLY;
        </code>
      </div>
      Daha eski sürümlerde ise;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY maas DESC <br />
          WHERE ROWNUM&lt;4;
        </code>
      </div>
      Eger en yüksek ilk %10'unu isteseydik;
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY maas DESC <br />
          FETCH NEXT 10 <strong>PERCENT</strong> ROWS ONLY;
        </code>
      </div>
      MAAŞ'a göre sıralamada 4. 5. ve 6. kişilerin bilgilerini listeleyen
      sorguyu yazınız.
      <div class="cerceve">
        <code>
          SELECT * FROM kisiler <br />
          ORDER BY maas DESC <br />
          <strong>OFFSET</strong> 3 ROWS <br />
          FETCH NEXT 3 ROWS ONLY;
        </code>
      </div>
      OFFSET diyerek ilk üc satiri geciyoruz ve sonraki üc satiri yazdiriyoruz.
      Eski yol ile yazacak olursak;
      <div class="cerceve">
        <code>
          SELECT * FROM (SELECT * FROM (SELECT * FROM kisiler <br />
          ORDER BY maas DESC) <br />
          WHERE ROWNUM &lt;=6) <br />
          WHERE ROWNUM &lt;=3;
        </code>
      </div>
      <hr />
      <h3>GROUP BY</h3>
      GROUP BY cümleciği bir SELECT ifadesinde satırları, sutunların değerlerine
      göre özet olarak gruplamak için kullanılır. <br /><br />
      GROUP BY cümleciği her grup başına bir satır döndürür. <br /><br />
      GROUP BY genelde, AVG(),COUNT(),MAX(),MIN() ve SUM() gibi aggregate
      fonksiyonları ile birlikte kullanılır.
      <h4>Örnek</h4>
      Kisi ismine göre satilan toplam meyve miktarlarini gösteren sorguyu
      yaziniz. (Ahmet=5)
      <div class="cerceve">
        <code>
          SELECT isim, SUM (urun_miktari) AS toplam_urun FROM manav <br />
          GROUP BY isim;
        </code>
      </div>
      Satilan meyve türüne göre ürün alan kisi sayisini gösteren sorgu yaziniz.
      NULL olarak girilen meyve varsa listelenmesin.
      <div class="cerceve">
        <code>
          SELECT urun_adi, COUNT(isim) FROM manav <br />
          WHERE urun_adi IS NOT NULL <br />
          GROUP BY urun_adi;
        </code>
      </div>
      Ürün adindan bir tane yazar ve karsisina kisi sayisi yazar. (Armut=3)
      <hr />
      <h4>Siralama Yaparken:</h4>
      <ol>
        <li><strong>SELECT FROM</strong> ile basla,</li>
        <li><strong>WHERE</strong> ile gruplamadan evvel bazilarini ele,</li>
        <li><strong>GROUP BY</strong> ile özelliklerine göre grupla,</li>
        <li>
          <strong>HAVING</strong> ile grup özellillerine göre bir sart ile ele,
        </li>
        <li>
          <strong>ORDER BY</strong> ile bu gruplari istenilen özellige göre
          sirala.
        </li>
      </ol>
      <strong>HAVING</strong> : Sorgu isleminden sonra olusan
      <strong>yeni</strong> bir sütun icin bir sart konulacaksa kullanilir.
      <br />
      <code> HAVING SUM (urun_miktari)&gt;=3 </code> <br />
      Ürün miktari 3 ve daha büyüklerini listeler.
      <hr />
      <h3>DISTINCT (Tekrar Önleyici)</h3>
      DISTINCT cümleciği bir SORGU ifadesinde benzer olan satırları flitrelemek
      için kullanılır. Dolayısıyla seçilen sutun ya da sutunlar için benzersiz
      veri içeren satırlar oluşturmaya yarar. (ayni datalari görmezden gelir)
      <h4>Örnek</h4>
      Satilan farkli meyve türlerinin sayisini listeleyen sorgu yaziniz.
      (üzüm=3)
      <div class="cerceve">
        <code>
          SELECT COUNT (DISTINCT urun_adi) AS urun_cesit_sayisi FROM manav;
        </code>
      </div>
      Eger COUNT'u koymazsak NULL olanlari da sayacaktir.
      <hr />
      <h3>SELECT - LIKE</h3>
      LIKE anahtar kelimesi, sorgulama yaparken belirli patternleri
      kullanabilmemize olanak sağlar. <br />
      Pattern icin;
      <ul>
        <li>
          <strong>%</strong> : Yazildigi tarafta karakterler gelebilir veya
          gelmeyebilir.
        </li>
        <li>
          <strong>_</strong> : Yazildigi yerde bir tane karakteri temsil eder.
        </li>
      </ul>
      <h4>Örnek</h4>
      Ismi A harfi ile baslayanlari listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE isim <strong>LIKE</strong> 'A%';
        </code>
      </div>
      Ismi A harfi ile baslamayanlari listeleseydik;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE isim <strong>NOT LIKE</strong> 'A%';
        </code>
      </div>
      Ismi n harfi ile bitenleri listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE isim LIKE '%n';
        </code>
      </div>
      Ismi ikinci harfi e olup icinde y harfi gecen isimleri listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE isim LIKE '_e%y%';
        </code>
      </div>
      Maasinin son iki hanesi 00 olanlari listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE maas LIKE '%00';
        </code>
      </div>
      Maasinin 5 haneli olanlari listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE maas LIKE '_____';
        </code>
      </div>
      <hr />
      <h3>SELECT - REGEXP_LIKE</h3>
      Daha karmaşık pattern ile sorgulama işlemi için REGEXP_LIKE
      kullanılabilir.
      <ul>
        <li>
          <strong>'c'</strong> : case-sentisitive demektir ve zaten default
          olarak case-sensitive aktiftir.
        </li>
        <li>
          <strong>'i'</strong> : incase-sentisitive demektir. Harfin büyük veya
          kücük olmasi önemli degildir.
        </li>
        <li>
          <strong>^</strong> : baslangic oldugunu belirtmek icin kullanilan bir
          isarettir.
        </li>
        <li>
          <strong>$</strong> : yazildigi tarafta herhangi bir karakter olmadigi
          manasina gelen bir isarettir.
        </li>
      </ul>
      <h4>Örnek</h4>
      Icinde "hi" hecesi gecen kelimeleri listeleyelim; (LIKE gibi)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE <strong>REGEXP_LIKE</strong> (kelime,'hi');
        </code>
      </div>
      Icinde "ot" veya "at" hecesi gecen kelimeleri listeleyelim;
      (case-sensetive olmasin)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'ot|at','i');
        </code>
      </div>
      Baslangicinda "ho" veya "hi" hecesi olan kelimeleri listeleyelim;
      (case-sensetive olmasin)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'^ho|^hi','i');
        </code>
      </div>
      Son harfi "t" veya "m" olan kelimeleri listeleyelim; (case-sensetive
      olmasin)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'t$|m$','i');
        </code>
      </div>
      "h" ile baslayip "t" ile biten 3 harfli kelimeleri listeleyelim;
      (case-sensetive olmasin)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'h[a-zA-Z0-9]t','i');
        </code>
      </div>

      "h" ile baslayip "t" ile biten ortada da "o" veya "a" harfi bulunan 3
      harfli kelimeleri listeleyelim; (case-sensetive olmasin)
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'h[oa]t','i');
        </code>
      </div>
      icinde "m" veya "i" veya "e" olan kelimeleri listeleyelim;
      <div class="cerceve">
        <code>
          SELECT * FROM kelimeler <br />
          WHERE REGEXP_LIKE (kelime,'m|i|e');
        </code>
      </div>
      <hr />
      <h3>SET (küme) OPERATORLERI:</h3>
      <ol>
        <li>
          <strong>UNION</strong>
          <ul>
            <li>
              Eger tek sorguda birlestiremeyecegim iki sorgunun sonucunu
              <strong>ayni tabloda</strong> gormek istersek UNION islemi
              kullanilir.
            </li>
            <li>
              Bu durumda dikkat etmemiz gereken konu iki sorguda da
              <strong>field sayisi</strong> ve alt alta gelecek field
              <strong>data tipleri</strong>nin ayni olmasidir.
            </li>
            <li>
              UNION operatoru SADECE benzersiz degerleri alır. yani tekrar eden
              verileri sadece 1 kez alacaktir.
            </li>
          </ul>
        </li>
        <li>
          <strong>UNION ALL</strong>
          <ul>
            <li>
              UNION ALL komutu ise <strong>tekrara bakmaksizin</strong> iki
              sorgudan gelen tum sonuclari listeler.
            </li>
            <li>
              UNION ALL komutunda da iki sorgunun sonucunun
              <strong>esit sayida field</strong>'a ve
              <strong>data tipleri</strong>ne sahip olmasi gereklidir
            </li>
            <li>
              Benzerli verileri almak için UNION ALL kullanılır. Yani ayni
              datadan ne kadar varsa hepsini alacaktir.
            </li>
          </ul>
        </li>
        <li>
          <strong>INTERSECT</strong>
          <ul>
            <li>Iki kümenin <strong>kesişim</strong>ini döndürür</li>
            <li>
              INTERSECT operarotu 2 veya daha fazla Sorgu ifadesinin sonuclarini
              dondurmek icin kullanilir.
            </li>
            <li>
              Ancak, intersect SADECE tum sorgularin
              <strong>ortak veriler</strong>ini (kesisimlerini) dondurur.
            </li>
          </ul>
        </li>
        <li>
          <strong>MINUS</strong>
          <ul>
            <li>
              MINUS operatoru ilk Sorgu ifadesinde olup da diger sorgu
              ifadesinde olmayan verileri getirir.
            </li>
            <li>
              Yani 1. sorgu ile 2. sorgu arasindaki farklı olanları getirir.
            </li>
            <li>
              Minus; tekrarli satirlardan sadece bir adet yaazdirir.(UNION gibi)
            </li>
          </ul>
        </li>
      </ol>
      <h4>Örnek</h4>
      Maasi 4000'den yüksek olan isci isimlerini ve 5000'den fazla maas alinan
      sehirleri AYNI SÜTUNDA gösteren soruyu yaziniz. <br />
      (Tablodan örnek satir: 16456589654,'Ali Yilmaz','Istanbul',5500,'Honda')
      <div class="cerceve">
        <code>
          SELECT isim AS isim_veya_sehir,maas FROM personel <br />
          WHERE maas &gt;4000 <br />
          <strong>UNION</strong> <br />
          SELECT sehir,maas FROM personel <br />
          WHERE maas &gt;5000;
        </code>
      </div>
      UNION yerine UNION ALL da yazabilirdik, eger ayni data varsa her datayi
      yazardi. <br /><br />
      Personel tablosundan Istanbul veya Ankarada calisanlarin id'lerini
      sorgulayiniz, personel_bilgi tablosundan 2 veya 3 cocugu olanlarin
      id'lerini sorgilayiniz, bu iki sorgudaki ortak elemanlari birlestiriniz.
      <div class="cerceve">
        <code>
          SELECT id FROM personel <br />
          WHERE sehir IN ('Istanbul','Ankara') <br />
          <strong>INTERSECT</strong> <br />
          SELECT id FROM personel_bilgi <br />
          WHERE cocuk_sayisi IN (2,3);
        </code>
      </div>
      veya
      <div class="cerceve">
        <code>
          SELECT id FROM personel <br />
          WHERE sehir='Istanbul' OR sehir='Ankara' <br />
          INTERSECT <br />
          SELECT id FROM personel_bilgi <br />
          WHERE cocuk_sayisi=2 OR cocuk_sayisi=3;
        </code>
      </div>
      <br />
      Honda, Ford ve Tofas sirketinde calisan ortak isimde personel varsa
      listeleyiniz.
      <div class="cerceve">
        <code>
          SELECT isim FROM personel <br />
          WHERE sirket='Honda' <br />
          INTERSECT <br />
          SELECT isim FROM personel <br />
          WHERE sirket='Ford' <br />
          INTERSECT <br />SELECT isim FROM personel <br />
          WHERE sirket='Tofas';
        </code>
      </div>
      <br />
      500'den az maas alan ve Honda calisani olmayanlarin bilgilerini getiren
      bir sorgu yaziniz.
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE maas &lt;5000 <br />
          INTERSECT <br />
          SELECT * FROM personel <br />
          WHERE sirket != 'Honda';
        </code>
      </div>
      veya
      <div class="cerceve">
        <code>
          SELECT * FROM personel <br />
          WHERE maas &lt;5000 <br />
          <strong>MINUS</strong> <br />
          SELECT * FROM personel <br />
          WHERE sirket = 'Honda';
        </code>
      </div>
      <hr />
      <h3>JOIN İSLEMLERİ</h3>
      <ul>
        <li>
          Join islemleri ise farklı Tablolari birlestirmek icin kullanilir.
        </li>
        <li>
          Farkli tablolardaki secilen sutunlar ile yeni bir tablo olusturmak
          icin kullanilabilir.
        </li>
        <li>
          Set gibi sütunlari tek sütunda birlestirmez, sütunlari yan yana ekler.
        </li>
        <li>
          JOIN islemleri Iliskisel Veritabanlari icin cok onemli bir ozelliktir.
          Çunku Foreign Key'ler ile iliskili olan tablolardan istenilen
          sutunlari cekmek icin JOIN islemleri kullanilabilir.
        </li>
      </ul>
      ORACLE SQL'de 4 Cesit Join islemi kullanilabilmektedir.
      <ol>
        <li>
          <strong>FULL JOIN</strong>
          <ul>
            <li>
              FULL JOIN, Her iki tablo icin secilen sütunlara ait olan tüm
              satirlari getirmek icin kullanilir.
            </li>
            <li>
              Ortaklar aynı satırda yazılır, extra fazla satır varsa o da
              yazılır.
            </li>
          </ul>
        </li>
        <li>
          <strong>INNER JOIN</strong>
          <ul>
            <li>
              Iki tablonun kesisim kumesi ile yeni bir tablo olusturmak icin
              kullanilir.
            </li>
            <li></li>
          </ul>
        </li>
        <li>
          <strong>LEFT JOIN</strong>
          <ul>
            <li>
              Ilk yazilan tablodan SELECT ile ifade edilen sütunlara ait tüm
              satirlari getirir.
            </li>
            <li>
              Ancak diger tablodan sadece ON ile belirtilen kosula uyan
              satirlari getirir, ortak olmayan kisimlar bos kalir.
            </li>
          </ul>
        </li>
        <li>
          <strong>RIGHT JOIN</strong>
          <ul>
            <li>
              Ikinci yazilan tablodan SELECT ile ifade edilen sütunlara ait tüm
              satirlari getirir.
            </li>
            <li>
              Ilk tablodan sadece ON ile belirtilen kosula uyan(ortak) satirlari
              getirir.
            </li>
            <li>Ancak ortak olmayan kisimlar bos kalir.</li>
          </ul>
        </li>
      </ol>
      <h4>Örnek</h4>
      Sirketler ve siparisler adındaki tablolarda yer alan sirket_isim,
      siparis_id ve siparis_tarihleri listeleyen bir sorgu yaziniz.
      <div class="cerceve">
        <code>
          SELECT sirket_isim, siparis_id, siparis_tarihi,siparisler.sirket_id
          <br />
          FROM sirketler <br />
          <strong>FULL JOIN</strong> siparisler <br />
          ON sirketler.sirket_id=siparisler.sirket_id;
        </code>
      </div>
      Join'de WHERE yerine <strong>ON</strong> kullaniliyor ve iki tabloyu bu
      sütunlardan bagliyor. <br /><br />
      Iki Tabloda sirket_id'si ayni olanlarin sirket_ismi, siparis_id ve
      siparis_tarihleri listeleyen bir sorgu yaziniz. null olanlar çıkmıcak
      çünkü NULL ortak değil(bir tabloda null iken diğerinde id null yok, 100,
      101 vs var)
      <div class="cerceve">
        <code>
          SELECT sirket_isim, siparis_id, siparis_tarihi,siparisler.sirket_id
          <br />
          FROM sirketler <br />
          <strong>INNER JOIN</strong> siparisler <br />
          ON sirketler.sirket_id=siparisler.sirket_id;
        </code>
      </div>
      <br />
      Sirketler tablosundaki tüm sirketleri ve bu sirketlere ait olan siparis_id
      ve siparis_tarihlerini listeleyem bir sorgu yaziniz.
      <div class="cerceve">
        <code>
          SELECT
          sirket_isim,siparis_id,siparis_tarihi,siparisler.sirket_id,sirketler.sirket_id
          <br />
          FROM sirketler <br />
          <strong>LEFT JOIN</strong> siparisler <br />
          ON sirketler.sirket_id=siparisler.sirket_id;
        </code>
      </div>
      <br />
      Siparisler tablosundaki tüm siparis id ve siparis tarihleri ile bunlara
      karsilik gelen sirket isimlerini listeleyen bir sorgu yaziniz.
      <div class="cerceve">
        <code>
          SELECT sirket_isim,siparis_id,siparis_tarihi <br />
          FROM sirketler <br />
          <strong>RIGHT JOIN</strong> siparisler <br />
          ON sirketler.sirket_id=siparisler.sirket_id;
        </code>
      </div>
      <br />
      Satis ve Muhasebe bölümlerinde calisan personelin isimlerini ve
      bölümlerini, önce bölüm, sonra isim sirali olarak listeleyiniz.
      <div class="cerceve">
        <code>
          SELECT personel_isim, bolum_isim <br />
          FROM personel AS p <br />
          FULL JOIN bolumler AS b <br />
          ON b.bolum_id=p.bolum_id <br />
          WHERE bolum_isim IN ('Satis','Muhasebe') <br />
          ORDER BY bolum_isim, personel_isim;
        </code>
      </div>
      <hr />
      <h2>ALTER TABLE</h2>
      <ul>
        <li>
          ALTER TABLE tabloda ADD, MODIFY, veya DROP/DELETE COLUMNS islemleri
          icin kullanilir.
        </li>
        <li>
          ALTER TABLE ifadesi tablolari yeniden isimlendirmek (RENAME) icin de
          kullanilir.
        </li>
      </ul>
      <h4>Örnek</h4>
      Personel tablosuna ulke_ismi adinda ve default degeri 'Turkiye' olan bir
      sütun ekleyiniz.
      <div class="cerceve">
        <code>
          ALTER TABLE personel <br />
          <strong>ADD</strong> ulke_isim VARCHAR2(20)
          <strong>DEFAULT</strong> 'TURKIYE';
        </code>
      </div>
      virgül ile ekleme yapilabilir. ( <code>...,yas NUMBER(3),...</code>)
      <br /><br />
      Personel tablosundan yas sütununu siliniz.
      <div class="cerceve">
        <code>
          ALTER TABLE personel <br />
          <strong>DROP COLUMN</strong> yas;
        </code>
      </div>
      <br />
      Personel tablosundaki ulke_ismi sütununnun adini ulke_adi olarak
      degistiriniz.
      <div class="cerceve">
        <code>
          ALTER TABLE personel <br />
          <strong>RENAME COLUMN</strong> ulke_ismi <strong>TO</strong> ulke_adi;
        </code>
      </div>
      <br />
      Personel tablosunun adini insan_kaynaklari olarak degistiriniz.
      <div class="cerceve">
        <code>
          ALTER TABLE personel <br />
          <strong>RENAME TO</strong> insan_kaynaklari;
        </code>
      </div>
      <br />
      Insan_kaynaklari tablosundaki ulke_adi sütununna NOT NULL kisitlamasi ve
      VARCHAR(30) ekleyiniz.
      <div class="cerceve">
        <code>
          ALTER TABLE insan_kaynaklari <br />
          <strong>MODIFY</strong> ulke_adi VARCHAR(30) NOT NULL;
        </code>
      </div>
      Eger öncesinde herhangi bir NULL degeri girilmisse hata verecektir.
      <br /><br />
      Maas icin CHECK kisitlamasi ekleyelim;
      <div class="cerceve">
        <code>
          ALTER TABLE insan_kaynaklari <br />
          MODIFY maas CHECK (maas&gt;3000);
        </code>
      </div>
      Artik 3000'den kücük bir maas girilemez. <br />
      <hr />
      <!--



/*=============================== ALTER TABLE ==================================
    --iç kaporta için UPDATE (DML), dış kaporta için ALTER (DDL)
    ALTER TABLE  tabloda ADD, MODIFY, veya DROP/DELETE COLUMNS islemleri icin
    kullanilir.
    ALTER TABLE ifadesi tablolari yeniden isimlendirmek (RENAME) icin de
    kullanilir.
==========================================================*/

-->
    </main>
  </body>
</html>
